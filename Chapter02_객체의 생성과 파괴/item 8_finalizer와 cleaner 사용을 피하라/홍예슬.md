# 8. finalizer와 cleaner 사용을 피하라

자바는 두 가지 객체 소멸자를 제공한다.
### 자바의 객체 소멸자에는 ```finalizer```와 ```cleaner```가 있다.

하지만 기본적으로 둘 다 쓰지 말아야 한다.

finalizer와 cleaner는 즉시 수행된다는 보장이 없다. 객체에 접근할 수 없게 된 후 finalizer나 cleaner가 실행되기까지 얼마나 걸릴지 알 수 없다. finalizer나 cleaner를 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 이는 가비지 컬렉터 구현마다 천차만별이다. 또한 수행 시점에 의존하는 프로그램의 동작 또한 마찬가지다.

자바 언어 명세는 finalizer와 cleaner의 수행 시점뿐 아니라 수행 여부조차 보장하지 않는다. 접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다는 얘기다. 따라서 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.

finalizer와 cleaner는 심각한 성능 문제도 동반한다. finalizer와 cleaner는 객체를 생성하고 파괴하거나 클래스의 모든 인스턴스를 수거하는 형태로 사용하면 가비지 컬렉터의 효율을 떨어뜨리기 때문에 사용하지 않는 방법보다 훨씬 느리다.

finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. finalizer 공격 원리는 간단하다. 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다. 이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있다. final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언하자.

### 그렇다면 finalizer와 cleaner를 대신할 묘안은 무엇일까?
그저 ```AutoCloseable```을 구현해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다. 또한 각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋다.

### finalizer와 cleaner는 어디에 사용해야 할까?
(아마도) 두 군데 사용할 수 있다.

1. 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할이다.

이런 안전망 역할의 finalizer를 작성할 때는 그럴만한 값어치가 있는지 심사숙고하자. 자바 라이브러리의 일부 클래스는 안전망 역할의 finalizer를 제공한다. (ex. ```FileInputStream```, ```FileOutputStream```, ```ThreadPoolExecutor``` 등.)

2. 네이티브 피어(native peer)와 연결된 객체에서 활용한다.

네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알지 못한다. 단, 성능 저하를 감당할 수 없거나 네이티브 피어가 사용하는 자원을 즉시 회수해야 한다면 앞서 설명한 close 메서드를 사용해야 한다.

---

> cleaner(자바8까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자.
> 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.