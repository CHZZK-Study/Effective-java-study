# 11. equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.

다음은 Object 명세에서 발췌한 규약이다.
- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다. 
- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

hashCode 재정의를 잘못 했을 때 크게 문제가 되는 조항은 두 번째다. 즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다. equals는 논리적으로 두 객체가 같다고는 할 수 있지만, Object의 기본 hashCode 메서드는 이 둘이 전혀 다르다고 판단하여 서로 다른 값을 반환한다.

다음은 적법하지만 절대 사용해서는 안되는 구현 방법이다.
``` java
@Override public int hashCode() { return 42; }
```

이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법하다. 하지만 모든 객체에게 똑같은 값만 내어주므로 모든 객체가 해시테이블의 버킷 하나에 담겨 연결 리스트 형태로 동작한다. 그 결과 평균 수행 시간이 O(1)인 해시테이블이 O(n)으로 느려져서, 객체가 많아지면 쓸 수가 없다.

다음은 좋은 hashCode를 작성하는 간단한 요령이다.
1.  int 변수 result를 선언한 후 값 c로 초기화 한다. 
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.
    - 해당 필드의 해시코드 c를 계산한다.
        - 기본 타입의 필드라면 Type.hashCode(f)를 수행한다. Type은 해당 기본 타입의 박싱 클래스다.
        - 이 필드의 표준형을 만들어 그 표준형의 hashCode를 호출한다. 필드의 값이 null이면 0을 사용한다.
        - 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 배열에 핵심 원소가 하나도 없다면 단순이 상수(0 추천)를 사용하고, 모든 원소가 핵심 원소라면 Arrays.hashCode를 사용한다.
    - 이전 단계에서 계산한 해시코드 c로 result를 갱신한다. 코드로는 다음과 같다.
        ```
        // 곱할 숫자를 31로 정한 이유는 홀수이면서 소수이기 때문이다.
        result = 31 * result + c;
        ```
3. result 를 반환한다.

해당 메서드가 같은 인스턴스에 대해 똑같은 해시 코드를 반환할까? 그리고 검증할 단위 테스트를 작성하자. 파생 필드는 해시코드 계산에서 제외해도 되며, equals 비교에 사용되지 않은 필드는 반드시 제외한다. 

해당 방법으로 구현한 hashCode()는 다음과 같다.
``` java
// PhoneNumber라는 클래스에 적용할 때의 예를 말한다. 인스턴스의 핵심 필드 3개만을 사용해 만들었다.
@Override public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게되고, 추후에 계산 방식을 바꿀 수도 있다.

---

> 아이템 10에서 얘기한 AutoValue 프레임워크를 사용하면 멋진 equal와 hashCode를 자동으로 만들어 준다. 
> IDE 들도 이런 기능을 일부 제공하니 참고하자.