# Item 10. equals는 일반 규약을 지켜 재정의하라

equals는 재정의하기 쉬워 보이지만, 함정이 있다. 
문제를 회피하는 가장 좋은 방법은 아예 재정의하지 않는 것이다. 재정의하지 않고 그냥 두면
그 클래스의 인스턴스는 오직 자기 자신과만 같게 된다. 그러므로 다음 상황 중 하나에 해당된다면 재정의하지 않는 것이 최선이다.

## equals를 재정의하지 않아도 되는 경우

* 각 인스턴스가 본질적으로 고유할 때
  * '동작하는' 개체를 표현하는 클래스가 여기 해당된다. (예 : Thread)
* 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없을 때
* 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞을 때
  * Set이나 List 같은 컬렉션의 경우 대부분의 구현체가 AbstractSet이나 AbstractList의 equals를 상속받아 쓴다.
  * 이런 상황이라면 그 상위 클래스의 equals가 무엇을 하는지 확인해보고, 이를 그대로 써도 되는지 검토해보자.
* 클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없을 때
  * 만약 equals가 실수로라도 호출되는 걸 막고 싶다면 다음과 같이 구현하자.
  * ```java
    @Override public boolean equals(Object o) {
        throw new AssertionError(); // 호출 금지!
    }
    ```
    
## equals를 재정의해야 할 때
equals를 재정의해야 할 때는 상위 클래스의 equals가 논리적 동치성을 비교하도 재정의하지 않았을 때이다.
대부분의 값 클래스는 이런 상황에 해당한다. 값 클래스란 Integer나 String처럼 값을 표현하는 클래스를 말한다.

개발자는 이런 값 객체를 비교할 때 객체가 같은지가 아닌 '값이 같은지' 를 알고 싶어할 것이다.
이런 상황에서는 equals를 재정의해주어야 한다. equlas가 논리적 동치성을 비교하도록 재정의한다면, 값을 비교할 수 있을 것이다.
(+Set, Map의 원소로도 사용할 수 있다.)

</br>
값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스(Enum 등)라면
equals를 재정의하지 않아도 된다.

## equals 메서드를 재정의할 때 지켜야 할 일반 규약
다음은 Object 명세에 적힌 규약이다.

equals 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.
* 반사성(reflexivity) : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다.
* 대칭성(symmetry) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
* 추이성(transitivity) : null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
* 일관성(consistency) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
* null-아님 : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.

어렵지만, 꼭 알고 넘어가야 하는 부분이다. 이 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.

### 동치관계(equivalence relation)

동치관계란 집합을 서로 같은 원소들로 이루어진 부분집합들로 나누는 연산이다. 이 부분집합을 동치류(equivalence class)라고 한다.
equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다.

### 반사성(reflexivity)
> 객체는 자기 자신과 같아야 한다.

### 대칭성(symmetry)
> 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.
> 
간단히 말하자면, 어떤 객체 a와 b에 대해, a.equals(b)가 true를 반환한다면, b.equals(a)도 true를 반환해야 한다는 것이다.
대칭성을 위반하는 예제 코드는 다음과 같다. CaseInsensitiveString의 equals는 일반 String을 알고 있지만, String의 equals는 CaseInsensitiveString을 모른다.
```java
public final class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }

    // 대칭성 위반
    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString) {
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        }
        if (o instanceof String) {
            return s.equalsIgnoreCase((String) o);
        }
        return false;
    }
}
```

### 추이성(transitivity)
> 첫 번째 객체가 두 번째 객체와 같고, 두 번째 객체가 세 번째 객체와 같다면, 첫 번째 객체는 세 번째 객체와 같아야 한다.

상위 클래스에는 없는 새로운 필드를 하위 클래스에 추가하는 코드를 통해 추이성을 위반하는 예제를 보자.
```java
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // 추이성 위반
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Point)) {
            return false;
        }
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
}
```
```java
public class ColorPoint extends Point {
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    // 추이성 위반
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof ColorPoint)) {
            return false;
        }
        return super.equals(o) && ((ColorPoint) o).color == color;
    }
}
```
이제 Color Point에 값 비교를 하는 equals를 오버라이드 해보자.
```java
@Override public boolean equals(Object o) {
if (!(o instanceof ColorPoint))
return false;
return super.equals(o) && ((ColorPoint) o).color == color;
}
```
```java
Point x = new Point(1,2);
ColorPoint y = new ColorPoint(1,2,RED);

x.equals(y) // true
y.equals(x) // false
```

대칭성이 위배되는 것을 확인할 수 있다. 대칭성을 지키려면 어떻게 해야할까? ColorPoint의 equals메서드에서 Point인 경우는 Color 비교를 하지 않도록 하면 되지 않을까?
```java
@Override public boolean equals(Object o) {
if (!(o instanceof Point))
return false;

	// o가 일반 Point면 색상을 무시하고 비교한다.
	if (!(o instanceof ColorPoint))
		return o.equals(this);

	// o가 ColorPoint면 색상까지 비교한다.
	return super.equals(o) && ((ColorPoint) o).color == color;
}
```
이 방식은 대칭성은 지켜지지만 추이성은 지켜지지 않는다.
```java
ColorPoint p1 = new ColorPoint(1,2,RED);
Point p2 = new Point(1,2);
ColorPoint p3 = new ColorPoint(1,2,BLUE);

p1.equals(p2) // true
p2.equals(p3) // true
p1.equals(p3) // false
```

이제는 p1.equals(p2)와 p2.equals(p3)가 true이므로 p1.equals(p3)도 true가 되어야 하는데, false가 된다.
추이성에 위배되는 것을 확인할 수 있다. p1-p3 비교에서는 색상까지 고려해서 비교하기 때문이다.

사실 이 문제는 모든 객체 지향 언어에서 발생한다. instanceof 검사를 getClass 검사로 바꾸면 어떨까?
```java
@Override public boolean equals(Object o) {
if (o == null || o.getClass() != getClass())
return false;

	Point p = (Point) o;
	return p.x == x && p.y == y;
}
```
하지만 getClass는 실제로 활용할 수 없다. Point의 하위 클래스는 어디서든 Point로써 활용될 수 있어야 하기 때문이다. (리스코프 치환 원칙)
ColorPoint는 Point로서도 기능할 수 있어야 하는데, getClass를 통한 비교는 ColorPoint가 Point와 한 곳에 섞이는 걸 막을 것이기 때문이다.
이때문에 하위 클래스에서 상위 클래스에 값을 추가하는 것은 어렵다. '상속 대신 컴포지션을 활용하라'(item 18)는 방법을 통해 우회하는 방안이 있다.
Point를 상속하는 대신 Point를 ColorPoint의 private 필드로 두고, ColorPoint와 같은 위치의 일반 Point를 반환하는 뷰 메서드를 추가한다. 
```java
public class ColorPoint {
private final Point point;
private final Color color;

	public ColorPoint(int x, int y, Color color) {
		point = new Point(x, y);
		this.color = Objects.requireNonNull(color);
	}

	/**
	* 이 ColorPoint의 Point 뷰를 반환한다.
	*/
	public Point asPoint() {
	return point;
	}

	@Override public boolean equals(Object o) {
		if (!(o instanceof ColorPoint))
			return false;

		ColorPoint cp = (ColorPoint) o;
		return cp.point.equals(point) && cp.color.equals(color);
	}
	... // 나머지 코드 생략
}
```
