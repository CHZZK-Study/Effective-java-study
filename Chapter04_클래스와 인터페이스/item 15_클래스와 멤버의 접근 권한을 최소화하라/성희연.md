## item 15. 클래스와 멤버의 접근 권한을 최소화하라

---

### 1. `정보 은닉`이란?
우리가 객체 지향 프로그래밍이라는 것을 배우면서 많이 들었던 내용 중 하나가 바로 `정보 은닉`일 것이다.

`정보 은닉`은 무엇을 말하는걸까?  
클래스 내부 데이터와 내부 구현 정보를 외부로부터 완벽히 숨겨, 구현과 API를 깔끔하게 분리한 것을 말한다.  
이렇게 분리가 잘 되어 있으면, 사용자는 내부의 동작 방식에 대해서는 전혀 신경쓰지 않고 API만 호출하여 소통할 수 있다.

우리가 사용하는 외부 라이브러리가 그 예이다.

---

### 2. `정보 은닉`의 장점

1️⃣ **시스템 개발 속도를 높인다.**

2️⃣ **시스템 관리 비용을 낮춘다.**

3️⃣ **정보 은닉 자체가 성능을 높여주진 않지만, 성능 최적화에 도움을 준다.**

4️⃣ **소프트웨어 재사용성을 높인다.**

5️⃣ **큰 시스템을 제작하는 난이도를 낮춰준다.**

---

### 3. `정보 은닉`을 위한 기본 원칙
> **🔥 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다!  
> 즉, 소프트웨어가 정상 동작하는 한, 가장 낮은 접근 수준을 부여해야 한다는 것이다.**

위의 이야기를 다시 풀어서 이야기해보자.  
사용자가 API 사용을 통해 접근하게 되는 클래스와 인터페이스에 부여할 수 있는 접근 수준은 `public`과 `package-private` 두 가지다.  
해당 클래스/인터페이스를 `public`으로 선언하게 되면 외부에서 접근할 수 있는 공개 API가 되지만,  
`package-private`로 설정하게 되면 외부에서 접근할 수 없는 내부 구현이 된다.    

외부에서 접근할 수 없는 내부 구현이라는 말은 곧, 언제든지 수정하여도 클라이언트에게 피해를 끼치지 않는다는 뜻이다.  
반면, `public`인 경우 API가 되기 때문에 하위 호환을 위해 계속 관리가 필요할 것이다.

따라서 개발자의 의도대로 어플리케이션이 정상 동작한다면, 모든 클래스/인터페이스의 접근 수준(`public` or `private`)을 가장 낮은 접근 수준(`private`)으로 설정해야 한다는 이야기이다.

<br>

#### 3-1. 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준
1️⃣ `private`: 멤버를 선언한 클래스에서만 접근할 수 있다.

2️⃣ `package-private`: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.

3️⃣ `protected`: `package-private`의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근이 가능하다.

4️⃣ `public`: 모든 곳에서 접근할 수 있다.

---

### 4. 공개 API 외에는 모두 private로 만들고, 조건을 확인하여 특정 멤버에만 `package-private`로 풀어주자

공개해야 하는 API에 대해서만 우선 `public`으로 만들자.  
그런 다음, 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 `package-private`로 풀어주자.  

만일 이런 과정에서 권한을 풀어줘야 하는 일이 자주 발생한다면, **시스템에서 클래스(컴포넌트)를 더 분리해야하는 것은 아닐까** 한 번 고민해보자.  

`private`와 `package-private`는 보통 내부 구현에 속하기 때문에, 공개 API에는 영향을 주지 않는다.  
하지만 예외로 `Serializable`를 구현한 클래스에서는, 해당 클래스의 멤버가 의도치 않게 공개 API가 될 확률이 있음을 인지하자.  
이 부분에 대해서는 item 86, 87에서 더 다룰 예정이다.

또한 `protected`로 변경하게 되면, 해당 멤버에 접근할 수 있는 범위가 엄청나게 넓어진다.  
예를 들어 `public` 클래스의 `protected` 멤버는 공개 API이므로 사용자에게 공개되고, 계속 관리를 해주어야 한다.

---

### 5. 멤버의 접근성을 좁히지 못하게 방해하는 제약: `method override`

멤버의 접근 수준을 제일 낮게 설정하라는 규칙에 따르려고 하지만, 멤버의 접근성을 낮추기 못하게 하는 제약이 하나 있다.  
바로 `메서드 재정의`이다. 

메서드를 재정의할 때에는 해당 메서드의 접근 수준보다 좁게 설정할 수 없다.   
이것이 무슨 말인가? 풀어서 이야기를 해보자면,   
재정의 하고자하는 상위 클래스 메서드 `create()` 의 접근 수준이 `public`인 경우, 하위 클래스에서 메서드 `create()`를 재정의할 때에는 `public`밖에 사용하지 못한다.   
만일 상위 클래스의 메서드가 `protected`였다면, 하위 클래스에서는 `private`를 사용하지 못한다.   
하위 클래스의 접근 수준은 상위 클래스보다 좁으면 안되기 때문이다.

왜 이런걸까?  
`리스코프 치환 원칙(LSP)`에 따라 상위 객체와 하위 객체가 있을 때, 하위 객체는 상위 객체를 완전히 대체할 수 있어야 하기 때문이다.  
만일 하위 객체의 접근 수준이 더 좁다면 → 하위 객체가 상위 객체를 대체했을 때 해당 메서드를 호출할 수 없을지도 모르기 때문이다.


---
### 6. 코드 테스트 목적으로 멤버의 접근 범위를 넓혀도 좋을까?

테스트 코드를 작성하다보면 가끔 난관에 봉착하곤 한다.  
프로덕션 코드는 정상 작동하지만, 코드를 테스트할 목적으로 클래스 / 인터페이스 / 멤버의 접근 범위를 넓히고 싶을 때가 있다.  
어떻게 해야할까?

`private`를 `package-private` 수준으로 풀어주는 것까지는 허용할 수 있다. 하지만 그 이상은 안된다.   
즉, 테스트만을 위해 내부 구현으로 사용되고 있는 메서드를 공개 API로 만들어서는 안된다는 뜻이다.

테스트 코드를 테스트 대상과 같은 package에 두면 `package-private` 요소에 접근할 수 있다.  

하지만 spring에서는 test와 production 패키지가 분리되어 있기 때문에, `public` 메서드를 통해 `private`메서드를 테스트할 수 있도록 테스트 코드를 작성하는 것이 바람직할 것이다.


---

### 7. public 클래스의 인스턴스 필드는 되도록 `public`이 아니도록 하자

`public` 클래스의  1️⃣ **인스턴스 필드가 가변 객체를 참조**하거나, 2️⃣ **final이 아닌 인스턴스 필드를 public으로 선언**하면, 그 필드에 담을 수 있는 값을 제한할 수 없다.  
즉, 해당 필드와 관련된 모든 것은 불변임을 보장 할 수 없게 되는 것이다.

또한 필드가 수정될 때 다른 작업을 할 수 없게 되므로 `public 가변 필드를 갖는 클래스`는 일반적으로 스레드 안전(Thread-safe)하지 않다고 한다.  

인스턴스 필드 뿐만 아니라, 정적 필드에서도 마찬가지이다.  
단, 해당 클래스의 추상적인 개념을 표현하기 위해서 사용해야하는 상수라면 `public static final` 필드로 공개해도 괜찮다.  
예를 들어 영화관의 총 좌석이 23개인 상황일 때, 23을 `public static final String MAX_SEAT = 23;`과 같이 표현해도 괜찮다는 뜻이다.  
이런 경우에는 오히려 상수로 빼내면 요구사항이 변경되었을 때 관리하기 쉽다.  

`final` 상수의 이름은 대문자와 언더스코어(_)를 활용하며, 반드시 기본 타입 값이나 불변 개체를 참조해야 한다.


---

### 8. 클래스에서 public static final 배열 필드를 두거나, 해당 필드를 반환하는 접근자 메서드를 제공하면 안된다.

길이가 0이 아닌 배열은 모두 변경 가능하니 주의해야 한다.  
따라서 클래스에 배열인 필드가 있다면, `public static final`로 두면 안되고 && 해당 배열 필드를 반환하는 Getter 등을 제공해서는 안된다.  
그렇지 않은 경우, 외부에서 해당 배열에 대해 접근이 가능하게 될 것이며 의도한대로 정상 작동이 되지 않을 것이다.

<br>

#### 8-1. 해결책 1: 코드의 모든 public 배열을 private로 만들고, public 불변 리스트를 추가하라.
Java에서는 `Collections.unmodifiableList()`라는 메서드가 있다.  
해당 메서드의 매개변수에 Collection(배열)을 전달하면, 수정하지 못하는 배열을 반환하며, 수정을 시도하는 경우 예외를 발생시킨다.  

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = 
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)); // 불변 리스트를 반환
```

<br>

#### 8-2. 해결책 2: 배열을 private로 만들고, 해당 복사본을 반환하는 public 메서드를 추가하라. (방어적 복사)
배열에 대해 접근 수준을 private로 설정하고, 해당 배열의 복사본을 반환한다면 외부에서 배열에 수정을 가해도 실제 로직에 사용되는 배열에는 영향이 없을 것이다.

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```








