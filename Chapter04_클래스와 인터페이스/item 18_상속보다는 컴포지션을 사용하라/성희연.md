## item 18. 상속보다는 컴포지션을 사용하라

---

> 이번 아이템에서 이야기하는 `상속`은 클래스가 다른 클래스를 확장하는 `구현 상속`을 이야기한다.  
> 인터페이스 상속과는 무관하다.

### 1. 구현 상속이 위험할 때

상속은 대체로 코드를 재사용할 수 있는 좋은 수단이지만, 항상 좋은 것 만은 아니다.  
잘못 사용하게 되면 오류를 발생시키기 쉬운 소프트웨어를 만들 수 있다.  

상위 클래스와 하위 클래스 모두 `같은 프로그래머가 통제하는 패키지 안`이라면, 상속도 안전한 방법이다.  
혹은, 애초에 `확장할 목적으로 설계`했으며 `문서화도 잘 되어있다`면 마찬가지로 안전한 방법이다.

하지만!  
일반적인 구체 클래스를 package의 경계를 넘어, 다른 package의 구체 클래스를 상속하는 것은 위험하다.  
무엇이 위험한지 살펴보자.

<br>

#### 1-1. ⚠️  상위 클래스는 release 마다 구현이 달라질 수 있으며, 이로 인해 하위 클래스가 오동작할 수 있다.

메서드 호출과 달리, 상속은 캡슐화를 깨뜨릴 수 있다.  
다르게 이야기하자면, 다음 릴리즈 시 상위 클래스의 구현이 달라질 수 있고, 이로 인해 하위 클래스의 코드를 일절 수정하지 않았음에도 불구하고 오동작할 수 있다는 뜻이다.  

따라서 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해야 하위 클래스에서 이에 대해 수정이 가능할 것이고, 그에 따라 오동작도 일어나지 않을 것이다.  

`HashSet`을 상속받아 `InstrumentedHashSet`이라는 클래스를 구현한다고 가정해보자.  
해당 클래스에서는 성능을 높이기 위해 `추가된 원소의 수`라는 필드를 추가로 가지고 있고, 원소가 추가될 때마다 해당 값을 반환한다고 가정해보자.

```java
public class InstrumentedHashSet<E> extends HashSet<E> {
    private int addCount = 0;
    
    public InstrumentedHashSet() { }
    
    public InstrumentedHashSet(int initCap, float loadFactor) {
        super(initCap, loadFactor);
    }
    
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    
    @Override public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }
    
    public int getAddCount() {
        return addCount;
    }
}
```
여기에서 `addAll()` 메서드를 통해 원소 3개를 더하고, `getAddCount()`를 호출했다고 가정해보자.  
개발자는 `3`이라는 값이 나올 것으로 기대할 것이다.  

하지만 실제로는 `6`을 반환한다. 왜 그럴까?

문제는 `super.addAll()`을 호출하면서 발생한다.  

1️⃣ `InstrumentedHashSet`에서 `addAll()`을 호출하면 `super.addAll()`을 호출한다.  
2️⃣ `HashSet`의 `addAll()`은 내부적으로 다시 `add()`를 호출한다.  
3️⃣ `InstrumentedHashSet`에서 `add()`를 재정의(`override`) 했기 때문에, `InstrumentedHashSet`의 `add()`가 호출된다.  
4️⃣ `addCount++`가 실행되며, 의도했던 것보다 더 많은 값이 추가된다.

`HashSet`처럼 자신의 다른 부분(메서드)를 사용하는 `자기 사용(self-use)`은 클래스의 내부 구현 방식에 해당하는데,  
이 방식이 자바 플랫폼의 전반적인 정책인지, 다음 릴리즈에서도 적용이 될지는 모른다.  
결국 `InstrumentedHashSet` 또한 깨지기 쉬운 클래스가 되어버린다.

<br>

#### 1-2. ⚠️ 다음 release 때 상위 클래스에 새로운 메서드가 추가되었을 때

상황을 가정해보자.  
예를 들어, 보안적인 이슈로 인해 `Collection`에 추가된 모든 원소가 특정 조건을 만족해야만 하는 프로그램이 있다고 가정해보자.  
해당 `Collection`을 상속한 후, 원소를 추가하는 모든 메서드를 재정의하여 조건에 맞는지 검사하는 로직을 추가하면 될 것이다.  

그런데 다음 릴리즈에서 상위 클래스에 원소를 추가하는 메서드가 새로 생겼다면?  
하위 클래스에서 해당 메서드를 재정의하기 전까지, `조건에 맞지 않는 원소`가 추가될 수 있다.

<br>

#### 1-3. ⚠️ 메서드 재정의가 아닌, 새로운 메서드를 만들었을 때에도 상위 클래스와 충돌날 수 있다. 

`1-1`과 `1-2`의 문제점은 모두 메서드 재정의(Method override)로 인해 발생했다.  
그렇다면 메서드 재정의가 아닌, 새로운 메서드를 추가하면 괜찮지 않을까?

아니다. 그래도 위험은 여전히 존재한다.

1️⃣ **다음 릴리즈에서 상위 클래스에 새로운 메서드가 추가됐는데, 하위 클래스에 있던 메서드와 시그니처가 같고 반환타입이 다를 때**   
하위 클래스에서 컴파일 조차 되지 않을 것이다.

2️⃣ **하위 클래스와 시그니처, 반환타입이 모두 같을 때**   
만일 반환타입까지 모두 같다고 하더라도, `1-1`과 `1-2`와 같이 메서드를 제정의한 것이므로 똑같은 문제가 발생할 수 있다.


---
### 2. 해결 방법: `Composition`을 사용하라

1️⃣ **`Composition`이란?**
> 새로운 클래스를 만들고, `private` 필드로 기존 클래스의 인스턴스를 참조하게 하라.  
> 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 `Composition` 이라고 한다.

2️⃣ **`전달(forwarding)`과 `전달 메서드(forwarding method)`란?**   
> `전달`이란, 새 클래스의 메서드들이, `private` 필드로 참조하는 기존 클래스에 대응하는 메서드를 호출하여 그 결과를 반환하는 것을 말한다.  
> `전달 메서드`란, 새 클래스 안에 있는 메서드들을 말한다.

<br>

#### 2-1. `Composition` 방식의 이점
1. 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어난다.
2. 기존 클래스에 새로운 메서드가 추가되더라도 영향을 받지 않는다.

밑의 코드는 위의 예시를 `전달(forwarding)`의 방식으로 바꾼 전달 클래스이다.
```java
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> set;
    
    public ForwardingSet(Set<E> set) { this.set = set; }
    
    // Set의 method들을 implements하여 모두 구현
}
```
`Set` 인터페이스를 구현했고, `Set`의 인스턴스를 인수로 받는 생성자를 하나 제공한다.  
임의의 Set에 추가적인 기능을 덧씌워 새로운 Set을 만드는 것이 이 클래스의 핵심이다.

구체 클래스를 각각 따로 확장해야 했던 구현 상속과 달리, `Composition` 방식은 한 번만 구현해두면 어떠한 Set 구현체가 와도 활용할 수 있다.

<br>

#### 2-2. `Wrapper class`
> `Wrapper class`란, 위의 ForwardingSet과 같이 다른 Set을 감싸고(`wrap`) 있다는 뜻에서 Wrapper class라고 부르며,  
> 다른 기능을 덧씌운다는 개념에서 `Decorator pattern`이라고 한다.  
> 
> Composition과 전달(forwarding)은 넓은 의미로 위임(delegation)이라고 부르기도 하는데,  
> 엄밀히 이야기하자면, `Wrapper 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우`에만 위임에 해당한다.


---

### 3. 정리
1. 상속은 반드시 상위 클래스와 하위 클래스가 `is-a 관계`일 때에만 사용해야 한다.  
    만일 `is-a` 관계가 아니라면 `Composition` 방식을 사용하는 것이 바람직하다.
2. `Composition`을 사용해야하는 상황에서 상속을 사용하는 것은, 내부 구현을 불필요하게 공개하는 꼴이다.
3. 상속을 사용하기 전에 마지막으로 '확장하려는 클래스의 API에 아무련 결함이 없는가? 결함이 있을 때 하위 클래스에 전파되어도 영향이 없는가?'를 꼭 생각해보자.
