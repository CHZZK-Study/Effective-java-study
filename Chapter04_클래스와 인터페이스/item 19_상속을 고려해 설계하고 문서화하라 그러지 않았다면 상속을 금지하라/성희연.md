## item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

---

### 1. 상속용 클래스는 재정의할 수 있는 메서드들에 대해 문서화해야 한다

item 18에서는 상속보다 컴포지션을 사용하라는 조언을 했다.  
이는 상속을 염두해두지도 않고, 상속할 때의 주의점도 문서화해놓지 않은 "외부 클래스"를 상속할 때의 경고이다.  
여기서 `외부`란, 프로그래머의 통제권 밖에 있어 언제 어떻게 변경될지 모르는 것을 이야기한다.

따라서 상속을 목적으로 설계된 클래스에 대해서는, 클래스 내에 재정의할 수 있는 메서드들에 대해 내부적으로 어떻게 이용해야하는지 문서로 남겨야 한다.  

상속용 클래스의 공개된 메서드 A와 B가 있다고 가정하자. 메서드 A가 메서드 B를 호출하는, 즉, 자신의 또 다른 메서드를 호출하는 일이 생길 수도 있다.  
이런 상황에서는 메서드 A의 `API 설명`에 어떤 순서로 호출해야 하는지, 어떤 영향을 주는지와 같은 설명을 적어야 한다.

메서드 주석에 `@implSpec` 어노테이션을 사용하여 Javadoc 을 활용할 수 있다.  
`@implSpec` 태그를 사용하면 Javadoc 도구가 생성해준다.

<br>

---

### 2. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 선별하여, `protected` 형태로 공개해야 할 수 있다.

내부 매커니즘에 대해 문서로 남기는 것 뿐만 아니라, 몇몇 메서드를 필요에 의해 protected로 공개함으로서 하위 클래스를 효율적으로 만들 수 있다.

`java.util.AbstractList`의 `removeRange`를 예로 들어보자.
```java
    /**
     * Removes from this list all of the elements whose index is between
     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
     * Shifts any succeeding elements to the left (reduces their index).
     * This call shortens the list by {@code (toIndex - fromIndex)} elements.
     * (If {@code toIndex==fromIndex}, this operation has no effect.)
     *
     * <p>This method is called by the {@code clear} operation on this list
     * and its subLists.  Overriding this method to take advantage of
     * the internals of the list implementation can <i>substantially</i>
     * improve the performance of the {@code clear} operation on this list
     * and its subLists.
     *
     * @implSpec
     * This implementation gets a list iterator positioned before
     * {@code fromIndex}, and repeatedly calls {@code ListIterator.next}
     * followed by {@code ListIterator.remove} until the entire range has
     * been removed.  <b>Note: if {@code ListIterator.remove} requires linear
     * time, this implementation requires quadratic time.</b>
     *
     * @param fromIndex index of first element to be removed
     * @param toIndex index after last element to be removed
     */
    protected void removeRange(int fromIndex, int toIndex) {
        ListIterator<E> it = listIterator(fromIndex);
        for (int i=0, n=toIndex-fromIndex; i<n; i++) {
            it.next();
            it.remove();
        }
    }
```

사실 `List`를 사용하는 사용자는 `removeRange` 메서드에 대해 알지 못해도 된다. 그럼에도 불구하고 `protected`로 공개한 이유는 `clear()` 메서드의 성능을 위해서이다.  

문서로 적혀있는 내용을 확인해보면 clear 연산이 이 메서드를 호출하고, `ListIterator.remove`가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례하므로, 필요에 따라 재정의 하라는 이야기를 확인할 수 있다.    
만일 `removeRange`를 `protected`로 열어놓지 않았다면 구조에 따라 성능이 천차만별이 될 것이고, 성능을 개선하기 위해 제일 밑 부분부터 구현해야 할 수도 있다.  

<br>

그렇다면 상속용 클래스를 설계할 때 `protected`로 열어놓을 메서드는 어떻게 결정할까?  
이 책에서는 안타깝게도 특별한 공식은 없다고 한다.   

상속용 클래스의 하위 클래스를 직접 만들어본 후, 꼭 필요한 메서드들에 대해서만 `protected`로 열어놓는 방법을 추천한다.  
하위 클래스 3개 정도면 충분한 검증이 가능하며, 이 중 하나는 제 3자가 작성해보는 것을 권장한다.

<br>

작성한 클래스가 두루두루 사용될 가능성이 높다고 판단되는 경우에는 문서화와 protected를 잘 활용하면서, 해당 내용이 클래스의 성능과 기능에 큰 영향을 끼칠 수 있음을 인지해야 한다.  

따라서 상속용으로 설계한 클래스에 대해서는 배포 전, 반드시 하위 클래스를 만들어 검증하자.


<br>

----

### 3. 상속용 클래스의 생성자는 직접적/간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

이 규칙을 어기는 경우에는 프로그램이 오작동할 가능성이 매우 높다.  
`상위 클래스의 생성자`가 하위 클래스의 생성자보다 `먼저 실행`되므로, `하위 클래스에서 재정의한 메서드`가 하위 클래스의 생성자보다 `먼저 호출`된다.

```java
public class Super {
    public Super() {
        overrideMe(); // 잘못된 예시 - 재정의 가능 메서드 호출
    }
    
    public void overrideMe() {  }
}
```

```java
public final class Sub extends Super {
    private final Instant instant;
    
    Sub() {
        instant = Instant.now();
    }
    
    // 재정의 가능 메서드 - 상위 클래스의 생성자가 호출
    @Override public void overrideMe() {
        System.out.println(instant);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```
`main`을 실행한 결과는 어떻게 될까?   

`Sub`를 생성하는 과정에서 `super()`를 자동으로 호출하기 때문에 `instant`를 두 번 출력할 것으로 예상하겠지만,   
첫 번째에는 `null`을 출력한다.

상위 클래스의 생성자가 하위 클래스의 생성자가 인스턴스 필드를 초기화하기 전에 `overrideMe`를 호출하기 때문이다.  
만일 이 상황에서 `instance`를 호출하게 된다면 `NullPointerException`이 발생할 것이다.



<br>

---

### 4. `clone()`과 `readObject()` 모두 직접적/간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

`Clonable`과 `Serializable` 인터페이스 둘 중 하나라도 구현한 클래스를 상속할 수 있게 해주는 것은 대체로 좋지 않은 생각이다.  
해당 클래스를 확장하려는 개발자들에게 많은 부담감을 주기 때문이다. (물론 해당 인터페이스를 하위 클래스에서 구현하는 방법도 있다)

`clone`과 `readObject`는 새로운 객체를 만들기 때문에 생성자와 비슷한 역할을 수행한다.  
상속용 클래스에서 `Clonable`이나 `Serializable` 인터페이스를 구현하고자 한다면, 이들을 구현할 때 발생하는 제약 또한 생성자와 비슷하다.  

따라서, `clone`과 `readObject` 모두 직접적이든 간접적이든 재정의 가능한 메서드를 호출해서는 안된다.     
1️⃣ `clone`은 하위 클래스의 clone 메서드가 복제본의 상태를 정렬하기도 전에 호출하고,
2️⃣ `readObject`는 하위 클래스에서 상태들이 역직렬화되기 전에 재정의한 메서드를 호출한다.   
이는 프로그램의 오작동으로 이어진다.

특히 `clone`의 경우에는 잘못되면 복제본뿐 만 아니라, 원본 객체에도 피해를 줄 수 있다.    
예를 들어 복제를 하는 과정에서 원본 객체의 자료구조의 참조를 가져가는 경우, 복제본을 수정했을 때 원본 객체에도 영향을 줄 수 있다.


<br>

---

### 5. 위 문제들을 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다!

상속을 금지하는 방법은 두 가지이다.  
1️⃣ 클래스를 `final`로 선언하기  
2️⃣ 모든 생성자를 `private` 혹은 `package-private`으로 선언하고, `public 정적 팩토리 메서드`를 제공하는 것이다.






